(function () {
    'use strict';

    angular
        .module('app.neighborTableModule')
        .factory('neighborTableData', neighborTableData);

    neighborTableData.$inject = ['$log', 'volumeCells', 'volumeStructures', 'volumeHelpers'];

    function neighborTableData($log, volumeCells, volumeStructures, volumeHelpers) {

        var self = this;

        self.Grouping = {
            TARGETLABEL: 0,
            CHILDTYPE: 1
        };

        self.histogramRowHeight = 100;
        self.histogramRowWidth = 200;
        self.defaultRowHeight = 30;

        var service = {
            getColumnDefs: getColumnDefs,
            getDefaultGridOptions: getDefaultGridOptions,
            getDetailsColumnDefs: getDetailsColumnDefs,
            getDetailsGridOptions: getDetailsGridOptions,
            getDetailsData: getDetailsData,
            getHeaderData: getHeaderData,
            getHistogramMaxYValueFromTable: getHistogramMaxYValueFromTable,
            getHistogramMaxYValueFromValues: getHistogramMaxYValueFromValues,
            getHistogramValues: getHistogramValues,
            getTableAsCsv: getTableAsCsv,
            getTableData: getTableData,
            getTableDataMaxValue: getTableDataMaxValue
        };

        service.Grouping = self.Grouping;
        service.histogramRowWidth = self.histogramRowWidth;

        return service;

        /**
         * @name getColumnDefs
         * @param header - header for the current config - generated by getHeaderData
         * @param sortFunction - applied to the columns
         * @returns List columns
         */
        function getColumnDefs(header, sortFunction, attribute) {
            var columns = [];

            for (var i = 0; i < header.length; ++i) {
                var column = {
                    field: header[i],
                    width: 100,
                    displayName: header[i]
                };

                if (i > 1) {
                    if (attribute == undefined) {
                        column.cellTemplate = 'neighborTable/neighborTableCell.html';
                        column.sortingAlgorithm = sortFunction;
                    } else {
                        column.width = self.histogramRowWidth;
                        column.cellTemplate = 'neighborTable/neighborTableHistogramCell.directive.html';
                    }
                } else {
                    if (i == 0) {
                        column.enableHiding = false;
                    }
                    column.allowCellFocus = false;
                    column.cellClass = 'overviewGridCell';
                    column.pinnedLeft = true;
                }

                columns.push(column);
            }

            return columns;
        }

        /**
         * @name getDefaultGridOptions
         * @param attribute - either distance or diameter - this will cause the rowHeight to be larger
         * @returns Object of grid options.
         */
        function getDefaultGridOptions(attribute) {

            var rowHeight = self.defaultRowHeight;
            if (attribute != undefined) {
                rowHeight = self.histogramRowHeight;
            }

            var gridOptions = {
                rowHeight: rowHeight,
                multiSelect: false,
                enableGridMenu: true
            };

            return gridOptions;
        }

        /**
         * @name getDetailsColumnDefs
         * @param grouping
         * @param attribute
         * @returns Array of column defs
         */
        function getDetailsColumnDefs(grouping, attribute) {

            if (grouping == self.Grouping.TARGETLABEL && attribute == undefined) {

                return [{
                    field: 'targetId',
                    displayName: 'target id',
                    width: 75
                }, {
                    field: 'count',
                    displayName: 'count',
                    width: 75
                }, {
                    field: 'childIds',
                    displayName: 'child ids'
                }];

            }
            else if (grouping == self.Grouping.TARGETLABEL && attribute != undefined) {

                return [{
                    field: 'childId',
                    displayName: 'child id',
                    width: 75
                }, {
                    field: 'targetId',
                    displayName: 'target id',
                    width: 75
                }, {
                    field: 'childValue',
                    displayName: 'child value'
                }];

            }
            else if (grouping == self.Grouping.CHILDTYPE && attribute == undefined) {

                return [{
                    field: 'childId',
                    displayName: 'child id',
                    width: 75
                }, {
                    field: 'targetId',
                    displayName: 'target id',
                    width: 75
                }, {
                    field: 'targetLabel',
                    displayName: 'target label'
                }];

            }
            else if (grouping == self.Grouping.CHILDTYPE && attribute != undefined) {

                return [{
                    field: 'childId',
                    displayName: 'child id',
                    width: 75
                }, {
                    field: 'targetId',
                    displayName: 'target id',
                    width: 75
                }, {
                    field: 'targetLabel',
                    displayName: 'target label'
                }, {
                    field: 'childValue',
                    displayName: 'child value'
                }];

            }
            else {
                throw 'getDetailsColumnDefs is fucked!';
            }
        }

        /**
         * @name getDetailsGridOptions
         * @returns Object of grid options with custom row template.
         */
        function getDetailsGridOptions() {
            var gridOptions = {};
            gridOptions.rowTemplate = 'common/rowTemplate.html';
            return gridOptions;
        }

        /**
         * @name getTableDetailsData
         * @param attribute
         * @param grouping
         * @param values
         */
        function getDetailsData(attribute, grouping, values) {

            var details = [];

            if (grouping == self.Grouping.TARGETLABEL && attribute == undefined) {

                var uniqueTargets = [];
                var childrenPerTarget = [];
                var numChildrenPerTarget = [];

                values.forEach(function (value) {
                    var id = volumeCells.getCellNeighborIdFromChildAndPartner(value.cellIndex, value.childIndex, value.partnerIndex);
                    var child = volumeCells.getCellChildAt(value.cellIndex, value.childIndex);
                    var currIndex = uniqueTargets.indexOf(id);
                    if (currIndex == -1) {
                        uniqueTargets.push(id);
                        currIndex = uniqueTargets.length - 1;
                        childrenPerTarget[currIndex] = '';
                        childrenPerTarget[currIndex] += child.id;
                        numChildrenPerTarget[currIndex] = 1;
                    } else {
                        childrenPerTarget[currIndex] += ', ' + child.id;
                        numChildrenPerTarget[currIndex] += 1;
                    }
                });

                uniqueTargets.forEach(function (target, i) {
                    details.push({
                        id: target,
                        count: numChildrenPerTarget[i],
                        children: childrenPerTarget[i]
                    });
                });

            }
            else if (grouping == self.Grouping.TARGETLABEL && attribute != undefined) {

                values.forEach(function (value) {
                    var targetId = volumeCells.getCellNeighborIdFromChildAndPartner(value.cellIndex, value.childIndex, value.partnerIndex);
                    var childId = volumeCells.getCellChildAt(value.cellIndex, value.childIndex);
                    var childValue = value.value;

                    details.push({
                        childId: childId,
                        targetId: targetId,
                        childValue: childValue
                    });
                });

            }
            else if (grouping == self.Grouping.CHILDTYPE && attribute == undefined) {


                values.forEach(function (value) {

                    var targetId = '';
                    var targetLabels = '';
                    if (value.partnerIndex == undefined) {

                        var partner = volumeCells.getCellChildPartnerAt(value.cellIndex, value.childIndex);

                        partner.neighborIds.forEach(function (neighborId, i) {

                            if (i == 0) {
                                targetId += neighborId;
                                targetLabels += volumeCells.getCell(neighborId).label;
                            } else {
                                targetId += ', ' + neighborId;
                                targetLabels += ', ' + volumeCells.getCell(neighborId).label;
                            }


                        });

                        details.push({
                            childId: volumeCells.getCellChildAt(value.cellIndex, value.childIndex).id,
                            targetId: targetId,
                            targetLabels: targetLabels
                        });
                    }

                });

                return details;

            }
            else if (grouping == self.Grouping.CHILDTYPE && attribute != undefined) {

                values.forEach(function (value) {

                    var targetId = '';
                    var targetLabels = '';

                    if (value.partnerIndex == undefined) {

                        var partner = volumeCells.getCellChildPartnerAt(value.cellIndex, value.childIndex);

                        partner.neighborIds.forEach(function (neighborId, i) {

                            if (i == 0) {
                                targetId += neighborId;
                                targetLabels += volumeCells.getCell(neighborId).label;
                            } else {
                                targetId += ', ' + neighborId;
                                targetLabels += ', ' + volumeCells.getCell(neighborId).label;
                            }


                        });

                        details.push({
                            childId: volumeCells.getCellChildAt(value.cellIndex, value.childIndex).id,
                            targetId: targetId,
                            targetLabels: targetLabels,
                            childValue: value.value
                        });
                    }

                });

                return details;

            }
            else {
                throw 'getDetailsColumnDefs is fucked!';
            }

            return details;
        }

        /**
         * @name getHeaderData
         * @returns List of strings to appear in the table of cell children.
         */
        function getHeaderData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping) {

            var header = [];

            header.push('id');
            header.push('label');

            if (childrenGrouping == self.Grouping.TARGETLABEL) {

                var targets = volumeHelpers.getCellChildTargets(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets);

                header = header.concat(targets);

            } else {

                var allChildTypes = volumeCells.getAllAvailableChildTypes();

                allChildTypes.forEach(function (childType) {
                    if (childTypes != undefined && childTypes.indexOf(childType) != -1) {
                        header.push(volumeStructures.getChildStructureTypeCode(childType))
                    } else if (childTypes == undefined) {
                        header.push(volumeStructures.getChildStructureTypeCode(childType))
                    }
                });

            }

            return header;
        }

        /**
         * @name getHistogramMaxYValueFromTable
         * @param table
         * @param header
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns Number - max length of histogram bin
         */
        function getHistogramMaxYValueFromTable(table, header, numBins, xAxisDomain, xAxisRange) {

            var maxYValue = 0;

            table.forEach(function (row) {
                header.forEach(function (column, i) {
                    if (i > 1) {
                        maxYValue = Math.max(getHistogramMaxYValueFromValues(row[column].values, numBins, xAxisDomain, xAxisRange), maxYValue);
                    }
                });
            });

            return maxYValue;
        }

        /**
         * @name getHistogramMaxYValueFromValues
         * @param values - list of CellChildValues
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns Number - max length of histogram bin
         */
        function getHistogramMaxYValueFromValues(values, numBins, xAxisDomain, xAxisRange) {

            // Create bins.
            var histogram = getHistogramValues(values, numBins, xAxisDomain, xAxisRange);

            var maxYValue = -1;

            // Find max sized bin
            histogram.forEach(function (bin) {
                maxYValue = Math.max(maxYValue, bin.length);
            });

            return maxYValue;

        }

        /**
         * @name getHistogramValues
         * @param values - list of CellChildValues
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns String csv of the current table (header + data).
         */
        function getHistogramValues(values, numBins, xAxisDomain, xAxisRange) {

            var x = d3.scale.linear()
                .domain(xAxisDomain)
                .range(xAxisRange);

            var justValues = values.map(function (d) {
                return d.value;
            });

            return d3.layout.histogram()
                .range(xAxisDomain)
                .bins(x.ticks(numBins))
                (justValues);
        }

        /**
         * @name getTableAsCsv
         * @returns String csv of the current table (header + data).
         */
        function getTableAsCsv(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping) {
            var csv = '';

            var header = getHeaderData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping);

            header.forEach(function (column, i) {

                csv += column;

                if (i != header.length - 1) {
                    csv += ', ';
                } else {
                    csv += '\n'
                }

            });

            var table = getTableData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping);

            table.forEach(function (row) {

                header.forEach(function (column, i) {

                    if (i != 0) {
                        csv += ', ';
                    }

                    if (i == 0 || i == 1) {
                        csv += row[column];
                    } else {
                        csv += row[column].values.length;
                    }
                });

                csv += '\n';
            });

            return csv;

        }

        /**
         * @name getTableData
         * @returns Array of Lists containing values for childrenTable.
         */
        function getTableData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping, maxCount, columnWidth, useBarsInTable, attribute) {

            var table = [];

            if (childrenGrouping == self.Grouping.TARGETLABEL) {
                cellIndexes.forEach(function (cellIndex) {

                    var results = volumeHelpers.getAggregateChildAttrGroupedByTarget([cellIndex], childTypes, useTargetLabelGroups, attribute, volumeHelpers.Units.PIXELS, cellIndexes);
                    var row = {};
                    var cell = volumeCells.getCellAt(cellIndex);
                    row.id = cell.id;
                    row.label = cell.label;

                    results.valuesLists.forEach(function (values, i) {
                        var currTarget = results.labels[i];

                        if (useOnlySelectedTargets) {
                            if (selectedTargets.indexOf(currTarget) != -1) {
                                row[currTarget] = {
                                    values: values,
                                    width: columnWidth,
                                    highlight: false
                                };
                            }
                        } else {
                            row[currTarget] = {
                                values: values,
                                width: columnWidth,
                                highlight: false
                            };
                        }

                    });
                    table.push(row);
                });

            } else if (childrenGrouping == self.Grouping.CHILDTYPE) {

                cellIndexes.forEach(function (cellIndex) {
                    var row = {};
                    var cell = volumeCells.getCellAt(cellIndex);
                    row['id'] = cell.id;
                    row['label'] = cell.label;

                    if (childTypes) {
                        childTypes.forEach(function (childType, i) {
                            var children = volumeCells.getCellChildrenByTypeIndexes(cellIndex, childType);
                            var childTypeCode = volumeStructures.getChildStructureTypeCode(childType);
                            row[childTypeCode] = {};
                            row[childTypeCode].values = volumeHelpers.createCellChildValues(cellIndex, children, attribute);
                            row[childTypeCode].width = columnWidth;
                        });
                    } else {
                        var allAvailableChildTypes = volumeCells.getAllAvailableChildTypes();
                        allAvailableChildTypes.forEach(function (childType, i) {
                            var children = volumeCells.getCellChildrenByTypeIndexes(cellIndex, childType);
                            var childTypeCode = volumeStructures.getChildStructureTypeCode(childType);
                            row[childTypeCode] = {};
                            row[childTypeCode].values = volumeHelpers.createCellChildValues(cellIndex, children, attribute);
                            row[childTypeCode].width = columnWidth;
                        });
                    }

                    table.push(row)
                });
            }

            return table;
        }

        /**
         * @name getTableDataMaxValue
         * @returns maxValue in the table - ignore the two most left columns.
         */
        function getTableDataMaxValue(header, table, attribute) {
            var maxValue = 0;

            table.forEach(function (row) {

                header.forEach(function (column, i) {

                    if (i > 1) {
                        if (attribute == undefined) {
                            maxValue = Math.max(maxValue, row[column].values.length);
                        } else {
                            var values = row[column].values;
                            values.forEach(function (value) {
                                maxValue = Math.max(maxValue, value.value);
                            });
                        }
                    }
                });
            });

            return maxValue;
        }

    }

})();

