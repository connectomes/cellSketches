(function () {
    'use strict';

    angular
        .module('app.neighborTableModule')
        .factory('neighborTableData', neighborTableData);

    neighborTableData.$inject = ['$log', 'volumeCells', 'volumeStructures', 'volumeHelpers'];

    function neighborTableData($log, volumeCells, volumeStructures, volumeHelpers) {

        var self = this;

        self.Grouping = {
            TARGETLABEL: 0,
            CHILDTYPE: 1
        };

        self.histogramRowHeight = 100;
        self.histogramRowWidth = 200;
        self.defaultRowHeight = 30;

        var service = {
            getColumnDefs: getColumnDefs,
            getDefaultGridOptions: getDefaultGridOptions,
            getHeaderData: getHeaderData,
            getHistogramMaxYValueFromTable: getHistogramMaxYValueFromTable,
            getHistogramMaxYValueFromValues: getHistogramMaxYValueFromValues,
            getHistogramValues: getHistogramValues,
            getTableAsCsv: getTableAsCsv,
            getTableData: getTableData,
            getTableDataMaxValue: getTableDataMaxValue
        };

        service.Grouping = self.Grouping;
        service.histogramRowWidth = self.histogramRowWidth;

        return service;

        /**
         * @name getColumnDefs
         * @param header - header for the current config - generated by getHeaderData
         * @param sortFunction - applied to the columns
         * @returns List columns
         */
        function getColumnDefs(header, sortFunction, attribute) {
            var columns = [];

            for (var i = 0; i < header.length; ++i) {
                var column = {
                    field: header[i],
                    width: 100,
                    displayName: header[i]
                };

                if (i > 1) {
                    if (attribute == undefined) {
                        column.cellTemplate = 'neighborTable/neighborTableCell.html';
                        column.sortingAlgorithm = sortFunction;
                    } else {
                        column.width = self.histogramRowWidth;
                        column.cellTemplate = 'neighborTable/neighborTableHistogramCell.directive.html';
                    }
                } else {
                    if (i == 0) {
                        column.enableHiding = false;
                    }
                    column.allowCellFocus = false;
                    column.cellClass = 'overviewGridCell';
                    column.pinnedLeft = true;
                }

                columns.push(column);
            }

            return columns;
        }

        /**
         * @name getDefaultGridOptions
         * @param attribute - either distance or diameter - this will cause the rowHeight to be larger
         * @returns Object of grid options.
         */
        function getDefaultGridOptions(attribute) {

            var rowHeight = self.defaultRowHeight;
            if (attribute != undefined) {
                rowHeight = self.histogramRowHeight;
            }

            var gridOptions = {
                rowHeight: rowHeight,
                multiSelect: false,
                enableGridMenu: true
            };

            return gridOptions;
        }

        /**
         * @name getHeaderData
         * @returns List of strings to appear in the table of cell children.
         */
        function getHeaderData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping) {

            var header = [];

            header.push('id');
            header.push('label');

            if (childrenGrouping == self.Grouping.TARGETLABEL) {

                var targets = volumeHelpers.getCellChildTargets(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets);

                header = header.concat(targets);

            } else {

                var allChildTypes = volumeCells.getAllAvailableChildTypes();

                allChildTypes.forEach(function (childType) {
                    if (childTypes != undefined && childTypes.indexOf(childType) != -1) {
                        header.push(volumeStructures.getChildStructureTypeCode(childType))
                    } else if (childTypes == undefined) {
                        header.push(volumeStructures.getChildStructureTypeCode(childType))
                    }
                });

            }

            return header;
        }

        /**
         * @name getHistogramMaxYValueFromTable
         * @param table
         * @param header
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns Number - max length of histogram bin
         */
        function getHistogramMaxYValueFromTable(table, header, numBins, xAxisDomain, xAxisRange) {

            var maxYValue = 0;

            table.forEach(function(row) {
               header.forEach(function(column, i) {
                   if (i > 1) {
                       maxYValue = Math.max(getHistogramMaxYValueFromValues(row[column].values, numBins, xAxisDomain, xAxisRange), maxYValue);
                   }
               });
            });

            return maxYValue;
        }

        /**
         * @name getHistogramMaxYValueFromValues
         * @param values - list of CellChildValues
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns Number - max length of histogram bin
         */
        function getHistogramMaxYValueFromValues(values, numBins, xAxisDomain, xAxisRange) {

            // Create bins.
            var histogram = getHistogramValues(values, numBins, xAxisDomain, xAxisRange);

            var maxYValue = -1;

            // Find max sized bin
            histogram.forEach(function(bin) {
                    maxYValue = Math.max(maxYValue, bin.length);
            });

            return maxYValue;

        }

        /**
         * @name getHistogramValues
         * @param values - list of CellChildValues
         * @param numBins - number of bins that the xAxisRange will be divided into
         * @param xAxisDomain - [0, maxValue]
         * @param xAxisRange - [0, width]
         * @returns String csv of the current table (header + data).
         */
        function getHistogramValues(values, numBins, xAxisDomain, xAxisRange) {

            var x = d3.scale.linear()
                .domain(xAxisDomain)
                .range(xAxisRange);

            var justValues = values.map(function (d) {
                return d.value;
            });

            return d3.layout.histogram()
                .range(xAxisDomain)
                .bins(x.ticks(numBins))
                (justValues);
        }

        /**
         * @name getTableAsCsv
         * @returns String csv of the current table (header + data).
         */
        function getTableAsCsv(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping) {
            var csv = '';

            var header = getHeaderData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping);

            header.forEach(function (column, i) {

                csv += column;

                if (i != header.length - 1) {
                    csv += ', ';
                } else {
                    csv += '\n'
                }

            });

            var table = getTableData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping);

            table.forEach(function (row) {

                header.forEach(function (column, i) {

                    if (i != 0) {
                        csv += ', ';
                    }

                    if (i == 0 || i == 1) {
                        csv += row[column];
                    } else {
                        csv += row[column].values.length;
                    }
                });

                csv += '\n';
            });

            return csv;

        }

        /**
         * @name getTableData
         * @returns Array of Lists containing values for childrenTable.
         */
        function getTableData(cellIndexes, childTypes, useTargetLabelGroups, useOnlySelectedTargets, selectedTargets, childrenGrouping, maxCount, columnWidth, useBarsInTable, attribute) {

            var table = [];

            if (childrenGrouping == self.Grouping.TARGETLABEL) {
                cellIndexes.forEach(function (cellIndex) {

                    var results = volumeHelpers.getAggregateChildAttrGroupedByTarget([cellIndex], childTypes, useTargetLabelGroups, attribute, volumeHelpers.Units.PIXELS, cellIndexes);
                    var row = {};
                    var cell = volumeCells.getCellAt(cellIndex);
                    row.id = cell.id;
                    row.label = cell.label;

                    results.valuesLists.forEach(function (values, i) {
                        var currTarget = results.labels[i];

                        if (useOnlySelectedTargets) {
                            if (selectedTargets.indexOf(currTarget) != -1) {
                                row[currTarget] = {
                                    values: values,
                                    width: columnWidth,
                                    highlight: false
                                };
                            }
                        } else {
                            row[currTarget] = {
                                values: values,
                                width: columnWidth,
                                highlight: false
                            };
                        }

                    });
                    table.push(row);
                });

            } else if (childrenGrouping == self.Grouping.CHILDTYPE) {

                cellIndexes.forEach(function (cellIndex) {
                    var row = {};
                    var cell = volumeCells.getCellAt(cellIndex);
                    row['id'] = cell.id;
                    row['label'] = cell.label;

                    if (childTypes) {
                        childTypes.forEach(function (childType, i) {
                            var children = volumeCells.getCellChildrenByTypeIndexes(cellIndex, childType);
                            var childTypeCode = volumeStructures.getChildStructureTypeCode(childType);
                            row[childTypeCode] = {};
                            row[childTypeCode].values = volumeHelpers.createCellChildValues(cellIndex, children, attribute);
                            row[childTypeCode].width = columnWidth;
                        });
                    } else {
                        var allAvailableChildTypes = volumeCells.getAllAvailableChildTypes();
                        allAvailableChildTypes.forEach(function (childType, i) {
                            var children = volumeCells.getCellChildrenByTypeIndexes(cellIndex, childType);
                            var childTypeCode = volumeStructures.getChildStructureTypeCode(childType);
                            row[childTypeCode] = {};
                            row[childTypeCode].values = volumeHelpers.createCellChildValues(cellIndex, children, attribute);
                            row[childTypeCode].width = columnWidth;
                        });
                    }

                    table.push(row)
                });
            }

            return table;
        }

        /**
         * @name getTableDataMaxValue
         * @returns maxValue in the table - ignore the two most left columns.
         */
        function getTableDataMaxValue(header, table, attribute) {
            var maxValue = 0;

            table.forEach(function (row) {

                header.forEach(function (column, i) {

                    if (i > 1) {
                        if(attribute == undefined) {
                            maxValue = Math.max(maxValue, row[column].values.length);
                        } else {
                            var values = row[column].values;
                            values.forEach(function(value) {
                                maxValue = Math.max(maxValue, value.value);
                            });
                        }
                    }
                });
            });

            return maxValue;
        }

    }

})();

